-- INSPECTING DATA
select *
from sales_data

-- CHECKING UNIQUE VALUES

SELECT DISTINCT STATUS FROM SALES_DATA;
SELECT DISTINCT YEAR_ID FROM SALES_DATA;
SELECT DISTINCT PRODUCT_LINE FROM SALES_DATA;
SELECT DISTINCT COUNTRY FROM SALES_DATA;

-- COLUMN DEAL_SIZE CONTAINS AN ERROE, WE WILL DELETE ONE ROW FROM THE DATA
SELECT DISTINCT DEAL_SIZE FROM SALES_DATA
WHERE DEAL_SIZE LIKE '%Medium3079.44';

-- DELETING ROW
DELETE FROM SALES_DATA
WHERE DEAL_SIZE LIKE '%Medium3079.44';

SELECT DISTINCT TERRITORY FROM SALES_DATA;

-- BEGIN ANALYSIS
-- LET'S BEGIN BY GROUPING SALES / REVENUE BY PRODUCT LINE - IT IS CLASSIC CARS
SELECT PRODUCT_LINE, 
		SUM(SALES) AS REVENUE
FROM SALES_DATA
GROUP BY 1
ORDER BY 2 DESC;

-- LET'S GROUP SALES / REVENUE BY YEAR - 2004 IS THE YEAR WITH THE MOST REVENUE, 2005 IS THE LOWEST
SELECT YEAR_ID, 
		SUM(SALES) AS REVENUE
FROM SALES_DATA
GROUP BY 1
ORDER BY 2 DESC;

-- WE TRY TO UNCOVER WHY 2005 HAS THE LOWEST SALES, WE CAN SEE THAT THE COMPANY OPERATED FOR JUST 5 MONTHS IN 2005
SELECT DISTINCT MONTH_ID
FROM SALES_DATA
WHERE YEAR_ID = 2005
ORDER BY 1;

-- LET'S GROUP SALES / REVENUE BY DEAL_SIZE - MEDIUM SIZE DEALS BRING IN MORE REVENUE
SELECT DEAL_SIZE, 
		SUM(SALES) AS REVENUE
FROM SALES_DATA
GROUP BY 1
ORDER BY 2 DESC;

-- WHAT WAS THE BEST MONTH FOR SALES IN A SPECIFIC YEAR? HOW MUCH WAS EARNED IN THAT MONTH? IT IS NOVEMBER
SELECT MONTH_ID,
		SUM(SALES) AS REVENUE,
		COUNT(ORDER_NUMBER) AS FREQUENCY_OF_ORDERS
FROM SALES_DATA
WHERE YEAR_ID = 2003 -- OR YEAR_ID = 2004
GROUP BY 1
ORDER BY 2 DESC;

-- NOVEMBER SEEMS TO BE THE MONTH WITH THE HIGHEST SALES. WHAT PRODUCT SELLS THE MOST IN NOVEMBER
SELECT MONTH_ID,
		PRODUCT_LINE,
		SUM(SALES) AS REVENUE,
		COUNT(ORDER_NUMBER) AS FREQUENCY_OF_ORDERS
FROM SALES_DATA
WHERE MONTH_ID = 11 AND YEAR_ID = 2004
GROUP BY 1, 2
ORDER BY 3 DESC;


/* WHO IS OUR BEST CUSTOMER? WE WILL DO AN RFM ANALYSIS TO ANSWER THIS
 IT IS AN INDEXING TECHNIQUE THAT USES PAST PURCHASE BEHAVIOR TO SEGMENT CUSTOMERS
 RFM USES 3 KEY METRICS - RECENCY, FREQUENCY AND MONETARY VALUE.
RECENCY - HOW LONG AGO THEIR LAST PURCHASE WAS I.E LAST PURCHASE DATE
FREQUENCY - HOW OFTEN THEY PURCHASE I.E COUNT OF TOTAL ORDERS
MONETARY VALUE - HOW MUCH THEY SPENT I.E TOTAL SPEND */

DROP TABLE IF EXISTS RFM_FINAL
;WITH RFM AS 
(
	SELECT CUSTOMER_NAME,
			SUM(SALES) AS MONETARY_VALUE,
			AVG(SALES) AS AVGMONETARYVALUE,
			COUNT(ORDER_NUMBER) AS FREQUENCY,
			MAX(ORDER_DATE) AS LAST_ORDER_DATE, -- MOST RECENT DATE THE CUSTOMER ORDERED AN ITEM
			(SELECT MAX(ORDER_DATE) FROM SALES_DATA) AS MAX_ORDER_DATE, -- MAXIMUM DATE IN THE DATASET
			(EXTRACT(DAY FROM (SELECT MAX(ORDER_DATE) FROM SALES_DATA) - MAX(ORDER_DATE))) AS RECENCY -- HOW RECENT THE CUSTOMER MADE AN ORDER
	FROM SALES_DATA
	GROUP BY CUSTOMER_NAME 
), RFM_CALC AS
(
	SELECT R.*,
			NTILE(4) OVER (ORDER BY RECENCY DESC) RFM_RECENCY, --1 IS LEAST RECENT
			NTILE(4) OVER (ORDER BY FREQUENCY) RFM_FREQUENCY, --1 IS LEAST FREQUENT
			NTILE(4) OVER (ORDER BY MONETARY_VALUE) RFM_MONETARY --1  IS THE LEAST MONETARY VALUE
	FROM RFM R
)
SELECT C.*,
		RFM_RECENCY + RFM_FREQUENCY + RFM_MONETARY AS RFM_CELL,
		CONCAT(RFM_RECENCY::VARCHAR, RFM_FREQUENCY::VARCHAR, RFM_MONETARY::VARCHAR) AS RFM_CELL_STRING
INTO RFM_FINAL -- TEMP TABLE
FROM RFM_CALC C;

-- HERE WE WILL GROUP OUR CUSTOMERS INTO CATEGORIES
SELECT 
	CUSTOMER_NAME,
	--RFM_RECENCY, 
	--RFM_FREQUENCY,
	--RFM_MONETARY,
	RFM_CELL_STRING, 
	CASE
		WHEN CAST(RFM_CELL_STRING AS INTEGER) IN (111, 112 , 121, 122, 123, 132, 211, 212, 114, 141) THEN 'LOST_CUSTOMERS'
		WHEN CAST(RFM_CELL_STRING AS INTEGER) IN (133, 134, 143, 221, 244, 144) THEN 'SLIPPING AWAY, CANNOT LOSE'
		WHEN CAST(RFM_CELL_STRING AS INTEGER) IN (311, 411, 331, 412) THEN 'NEW CUSTOMERS'
		WHEN CAST(RFM_CELL_STRING AS INTEGER) IN (222, 223, 232, 233, 234, 322, 421) THEN 'POTENTIAL CHURNERS'
		WHEN CAST(RFM_CELL_STRING AS INTEGER) IN (323, 333, 334, 343, 344, 321, 422, 332, 423, 432) THEN 'ACTIVE'
		WHEN CAST(RFM_CELL_STRING AS INTEGER) IN (433, 434, 443, 444) THEN 'LOYAL'
	END AS RFM_SEGMENT
FROM 
	RFM_FINAL
	--ORDER BY 5;


-- WHAT PRODUCTS ARE MOST OFTEN SOLD TOGETHER? WE WILL DO AN XML PATH HERE
-- select * from sales_data where order_number = 10411;

SELECT PRODUCT_CODE--string_agg(CONCAT(',', PRODUCT_CODE), '') AS concatenated_product_codes -- STRING AGG IS AN ALTERNATIVE TO "FOR XML PATH"
FROM SALES_DATA
WHERE ORDER_NUMBER IN
(
		SELECT ORDER_NUMBER
		FROM
		(
				SELECT ORDER_NUMBER,
						COUNT(*) RN
				FROM SALES_DATA
				WHERE STATUS = 'Shipped'
				GROUP BY 1
		) T1
		WHERE RN = 2 -- WE WANT TO KNOW THE TWO ITEMS ALWAYS BEING ORDERED TOGETHER
);

SELECT *
FROM SALES_DATA;














